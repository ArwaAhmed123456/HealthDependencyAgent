=======

app.use("/api/dependencies", dependencyRoutes);

// POST /execute route to handle supervisor task assignment messages
app.post("/execute", async (req, res) => {
  try {
    const message = req.body;

    // Basic validation for required fields
    if (!message.message_id || !message.sender || !message.recipient || !message.type || !message.task) {
      return res.status(400).json({
        status: "failed",
        result: { error: "Invalid message format: missing required fields" }
      });
    }

    if (message.recipient !== "dependency_health_agent") {
      return res.status(400).json({
        status: "failed",
        result: { error: "Wrong recipient: message not for this agent" }
      });
    }

    const { file_content_base64, file_type, project_name } = message.task;

    if (!file_content_base64 || !file_type) {
      return res.status(400).json({
        status: "failed",
        result: { error: "Invalid task format: missing file content or file type" }
      });
    }

    // Decode base64 content
    let fileContentStr;
    try {
      fileContentStr = Buffer.from(file_content_base64, "base64").toString("utf-8");
    } catch (e) {
      return res.status(400).json({
        status: "failed",
        result: { error: "Invalid base64 in file content" }
      });
    }

    let dependencies = {};

    if (file_type === "package.json") {
      // Parse JSON content
      let pkgJson;
      try {
        pkgJson = JSON.parse(fileContentStr);
      } catch (e) {
        return res.status(400).json({
          status: "failed",
          result: { error: "Invalid JSON in package.json" }
        });
      }

      dependencies = pkgJson.dependencies || {};
    } else if (file_type === "requirements.txt") {
      // Parse requirements.txt - each line package==version or package>=version
      dependencies = {};
      const lines = fileContentStr.split(/\r?\n/);
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed === "" || trimmed.startsWith("#")) continue;
        // Regex to parse package and version specifiers (simplified)
        const match = trimmed.match(/^([a-zA-Z0-9_-]+)([=><!~^]+)?(.+)?$/);
        if (match) {
          const pkg = match[1];
          const ver = match[3] ? match[3].trim() : "";
          dependencies[pkg] = ver || "unknown";
        }
      }
    } else {
      return res.status(400).json({
        status: "failed",
        result: { error: `Unsupported file type: ${file_type}` }
      });
    }

    // Call existing analyzeDependencies logic (simulate it here)
    // Note: analyzeDependencies expects req.body with dependencies or packageJson.
    // So we create a shallow mock request object with dependencies.
    const mockReq = { body: { dependencies } };
    // We will mock res object to capture json response.
    let analysisResult;
    const mockRes = {
      status: (code) => {
        return {
          json: (obj) => {
            analysisResult = obj;
            return obj;
          },
        };
      },
      json: (obj) => {
        analysisResult = obj;
        return obj;
      },
    };

    await analyzeDependencies(mockReq, mockRes);

    // Calculate total dependencies and overall health score
    const totalDependencies = analysisResult.length || 0;
    const overallHealthScore = totalDependencies
      ? Math.round(analysisResult.reduce((acc, dep) => acc + (dep.healthScore || 0), 0) / totalDependencies)
      : 0;

    res.status(200).json({
      message_id: `response-${Date.now()}`,
      sender: "dependency_health_agent",
      recipient: message.sender,
      type: "task_response",
      related_message_id: message.message_id,
      status: "completed",
      result: {
        project_name: project_name || "Unknown Project",
        file_type,
        total_dependencies: totalDependencies,
        overall_health_score: overallHealthScore,
        dependencies: analysisResult
      },
      timestamp: new Date().toISOString()
    });

  } catch (err) {
    console.error("Error in /execute route:", err);
    res.status(500).json({
      status: "failed",
      result: { error: "Internal server error" }
    });
  }
});
